# -*- coding: utf-8 -*-
"""Kshitij Gurung: Random Walk Project .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v8sVZnSBBOm29owpIAFvyhksj0aMl4xg

# Random Project
### Kshitij Gurung, 04.23.2020

Consider the following two-dimensional random walk that is not confined to integer-valued coordinates: the walk starts at the origin, and each step is a randomly chosen unit vector. That is, to
determine a step of the walk, first choose an angle θ (uniformly) from the interval [0, 2π). The step
of the walk will then be (cos(θ),sin(θ)).

Let's import some important libraries first.
"""

import matplotlib.pyplot as plt
import random
import numpy
import math

"""Let's define a function for the walk"""

def rand_Walk(n):
  locations = numpy.zeros((n+1,2))
  for i in range(1, n+1):
    angle = random.random()*math.pi*2
    move = numpy.array([math.cos(angle), math.sin(angle)])
    nextloc = locations[i-1] + move
    locations[i] = nextloc
  return locations

randomwalk = rand_Walk(100)
plt.plot(randomwalk[:,0], randomwalk[:,1]);

"""1. What is the average squared distance from the origin after n steps?

Let's define a function to calculate the squared
distance.
"""

def calculateSquaredDistance(arr):
  return (arr[0]**2 + arr[1]**2)

def calculateAverage(n):
  total = 0
  #run 100 walks for length n
  walks = [rand_Walk(n)[-1] for i in range(100)]
  for walk in walks:
    total += calculateSquaredDistance(walk)
  return total/100

calculateAverage(2000)

walks = [rand_Walk(100)[-1] for i in range(100)]

"""Let's do it for walks ranging from 1 to 1000."""

averages = [calculateAverage(i) for i in range(1, 500)]
plt.plot(averages)
plt.xlabel('Number of Steps (n)')
plt.ylabel('Averege Squared Distance from Origin');

"""It looks like the increase in the squared distance increases in a linear fashion.

2. When does the walk first return near the origin? Since the walk is not on a grid, it’s very
unlikely that it will return exactly to (0, 0). Instead, when does it return to a small circle
around the origin? For example, what is the average number of steps until the walk returns
to a circle of radius 0.5
around the origin?

Let's define a function that returns the step it takes to reach a circie of radius 0.5.
"""

def stepsUntilOrigin():
  currentPos = numpy.zeros(2)
  steps = 0
  while True:
    angle = random.random()*math.pi*2
    move = numpy.array([math.cos(angle), math.sin(angle)])
    currentPos[0] += move[0]
    currentPos[1] += move[1]
    steps += 1
    if calculateSquaredDistance(currentPos) < 0.5:
      return steps
    if steps > 1000:
      return None

stepsUntilOrigin()

Ori_return = [stepsUntilOrigin() for i in range(1000)]

new_retOrigin = list(filter((None).__ne__, Ori_return))

numpy.mean(numpy.array(new_retOrigin))

"""Based on 1000 iteration, it took 55.2 steps in average to return to a circle of radius 0.5.

3. How does the walk behave if it is constrained to the region −5 ≤ y ≤ 5? Modify your code to
keep the y-coordinate of the walk between −5 and 5. (You have freedom to decide how you
would like to do this!) Then reconsider questions 1 and 2 for your modified random walk.

This function keeps the random walk between -5 and 5 y-coordinate.
"""

def randomWalk_const(n):
  locations = numpy.zeros((n+1,2))
  for i in range(1, n+1):
    angle = random.random()*math.pi*2
    step = numpy.array([math.cos(angle), math.sin(angle)])
    if locations[i-1][1] > 5 or locations[i-1][1] < -5:
      continue
    nextloc = locations[i-1] + step
    locations[i] = nextloc
  return locations

randomwalknew = randomWalk_const(100)
plt.plot(randomwalknew[:,0], randomwalknew[:,1]);

def calculateAverageNew(n):
  total = 0
  #run 100 walks for length n
  walks = [randomWalk_const(n)[-1] for i in range(100)]
  for walk in walks:
    total += calculateSquaredDistance(walk)
  return total/100

averagesNew = [calculateAverageNew(i) for i in range(1, 500)]
plt.plot(averagesNew);

"""The average squared distances converge at about 30."""

randomwalknew = randomWalk_const(1000)
randomwalknew
plt.plot(randomwalknew[:,0], randomwalknew[:,1]);

step = 0
for i in range(len(randomwalknew)):
  step += 1
  if calculateSquaredDistance(randomwalknew[i]) < 0.5:
    break
print(step)

"""It generally returns to origin after the fist step.

The random walks behave differently when the constrains are changed.
"""

